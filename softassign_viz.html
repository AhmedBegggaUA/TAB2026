<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>SoftAssign – El Rectángulo</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Syne:wght@400;700;800&display=swap');

  :root {
    --bg: #ffffff;
    --panel: #faf8f6;
    --border: #e8dfd0;
    --accent: #ff8c42;
    --green: #2d9d5e;
    --red: #e74c3c;
    --blue: #3498db;
    --purple: #8e44ad;
    --text: #2c2c2c;
    --muted: #8b7355;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: linear-gradient(135deg, #ffffff 0%, #fff9f5 50%, #ffe8d9 100%);
    background-attachment: fixed;
    color: var(--text);
    font-family: 'Syne', sans-serif;
    min-height: 100vh;
    padding: 32px 24px;
  }

  h1 {
    font-size: 1.6rem;
    font-weight: 800;
    letter-spacing: -0.03em;
    color: #ff8c42;
    margin-bottom: 6px;
  }

  .subtitle {
    font-size: 0.85rem;
    color: #8b7355;
    font-family: 'JetBrains Mono', monospace;
    margin-bottom: 32px;
  }

  .layout {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    max-width: 1100px;
    margin: 0 auto;
  }

  .panel {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
  }

  .panel h2 {
    font-size: 0.8rem;
    font-family: 'JetBrains Mono', monospace;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: #b8985a;
    margin-bottom: 16px;
  }

  /* ── CANVAS AREA ── */
  .canvas-wrap {
    position: relative;
    width: 100%;
    aspect-ratio: 1;
    max-width: 340px;
    margin: 0 auto;
  }

  svg.graph-svg {
    width: 100%;
    height: 100%;
    overflow: visible;
  }

  /* ── STEP CONTROLS ── */
  .steps {
    display: flex;
    gap: 8px;
    margin-top: 16px;
    flex-wrap: wrap;
  }

  .step-btn {
    flex: 1;
    min-width: 80px;
    padding: 8px 10px;
    background: #ffffff;
    border: 1px solid var(--border);
    border-radius: 6px;
    color: #8b7355;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
  }
  .step-btn:hover { border-color: var(--accent); color: var(--accent); }
  .step-btn.active { background: var(--accent); color: #fff; border-color: var(--accent); font-weight: 700; }

  /* ── EXPLANATION BOX ── */
  .explanation {
    background: #ffffff;
    border-left: 3px solid var(--accent);
    border-radius: 0 8px 8px 0;
    padding: 14px 16px;
    font-size: 0.82rem;
    line-height: 1.6;
    min-height: 90px;
    transition: all 0.3s;
  }

  .explanation .tag {
    display: inline-block;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    padding: 2px 8px;
    border-radius: 4px;
    margin-bottom: 8px;
    font-weight: 700;
  }

  /* ── MATRIX DISPLAY ── */
  .matrix-area {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.75rem;
  }

  .matrix-label {
    font-size: 0.7rem;
    color: #8b7355;
    margin-bottom: 6px;
    text-transform: uppercase;
    letter-spacing: 0.1em;
  }

  table.mat {
    border-collapse: collapse;
    margin-bottom: 14px;
  }

  table.mat td {
    width: 38px;
    height: 34px;
    text-align: center;
    border: 1px solid var(--border);
    border-radius: 3px;
    transition: background 0.4s, color 0.4s;
    font-size: 0.72rem;
    position: relative;
  }

  table.mat th {
    width: 38px;
    height: 28px;
    text-align: center;
    color: #8b7355;
    font-size: 0.65rem;
    font-weight: 400;
  }

  .cell-hi   { background: rgba(255, 140, 66, 0.15); color: #ff8c42; font-weight: 700; }
  .cell-rect { background: rgba(45, 157, 94, 0.15);  color: #2d9d5e;  font-weight: 700; }
  .cell-dim  { opacity: 0.4; }

  /* ── LEGEND ── */
  .legend {
    display: flex;
    gap: 14px;
    flex-wrap: wrap;
    margin-top: 10px;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.72rem;
    color: #8b7355;
    font-family: 'JetBrains Mono', monospace;
  }
  .dot {
    width: 10px; height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  /* ── FORMULA ── */
  .formula {
    background: #ffffff;
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 12px 16px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.78rem;
    color: #ff8c42;
    margin-top: 12px;
    line-height: 1.8;
  }

  .formula span { color: #2c2c2c; }
  .formula .hi  { color: #27ae60; }
  .formula .hi2 { color: #1e6bb8; }
  .formula .hi3 { color: #6d28a0; }

  .arrow-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin: 8px 0;
    font-size: 0.75rem;
    color: #8b7355;
    font-family: 'JetBrains Mono', monospace;
  }
  .arrow-row .arrow { color: #ff8c42; font-size: 1rem; }

  /* full-width bottom panel */
  .full-panel {
    grid-column: 1 / -1;
  }

  .progress-bar {
    height: 3px;
    background: #e8dfd0;
    border-radius: 2px;
    margin-bottom: 20px;
    overflow: hidden;
  }
  .progress-fill {
    height: 100%;
    background: var(--accent);
    border-radius: 2px;
    transition: width 0.4s ease;
  }

  .nav-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 16px;
  }

  .nav-btn {
    padding: 8px 20px;
    background: transparent;
    border: 1px solid var(--accent);
    border-radius: 6px;
    color: var(--accent);
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.8rem;
    cursor: pointer;
    transition: all 0.2s;
  }
  .nav-btn:hover { background: var(--accent); color: #000; }
  .nav-btn:disabled { opacity: 0.3; cursor: default; }
  .nav-btn:disabled:hover { background: transparent; color: var(--accent); }

  .step-counter {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.75rem;
    color: var(--muted);
  }

</style>
</head>
<body>

<h1>SoftAssign — ¿Qué es un Rectángulo?</h1>
<p class="subtitle">// objetivo: maximizar rectángulos cerrados entre los dos grafos</p>

<div class="layout">

  <!-- LEFT: Graph visualization -->
  <div class="panel">
    <h2>Visualización del matching</h2>
    <div class="canvas-wrap">
      <svg class="graph-svg" id="mainSvg" viewBox="0 0 320 320"></svg>
    </div>
    <div class="legend" style="margin-top:14px">
      <div class="legend-item"><div class="dot" style="background:#60a5fa"></div>Grafo G1 (izq)</div>
      <div class="legend-item"><div class="dot" style="background:#c084fc"></div>Grafo G2 (der)</div>
      <div class="legend-item"><div class="dot" style="background:#f0c040"></div>Match activo M[a,i]</div>
      <div class="legend-item"><div class="dot" style="background:#4ade80"></div>Rectángulo cerrado</div>
    </div>
  </div>

  <!-- RIGHT: Explanation -->
  <div class="panel">
    <h2>Explicación paso a paso</h2>
    <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
    <div class="explanation" id="expBox"></div>

    <div class="formula" id="formulaBox" style="margin-top:14px"></div>

    <div class="nav-row">
      <button class="nav-btn" id="btnPrev" onclick="prevStep()">← Anterior</button>
      <span class="step-counter" id="stepCounter"></span>
      <button class="nav-btn" id="btnNext" onclick="nextStep()">Siguiente →</button>
    </div>
  </div>

  <!-- BOTTOM: Matrices -->
  <div class="panel full-panel">
    <h2>Matrices — estado actual</h2>
    <div style="display:flex; gap:32px; flex-wrap:wrap; align-items:flex-start">
      <div class="matrix-area">
        <div class="matrix-label">X — adyacencia G1</div>
        <div id="matX"></div>
      </div>
      <div class="matrix-area">
        <div class="matrix-label">Y — adyacencia G2</div>
        <div id="matY"></div>
      </div>
      <div class="matrix-area">
        <div class="matrix-label">M — matching actual</div>
        <div id="matM"></div>
      </div>
      <div class="matrix-area">
        <div class="matrix-label">Q — afinidad calculada</div>
        <div id="matQ"></div>
      </div>
    </div>
  </div>

</div>

<script>
// ── DATA ────────────────────────────────────────────────────────────────────
// 3-node graphs: G1 nodes a,b,c  |  G2 nodes 1,2,3
// X: a-b, b-c   Y: 1-2, 1-3, 2-3
const X = [[0,1,0],[1,0,1],[0,1,0]];
const Y = [[0,1,1],[1,0,1],[1,1,0]];

// Positions in SVG (left graph G1, right graph G2)
const pos1 = { a:[60,60], b:[60,200], c:[160,130] };   // G1
const pos2 = { 1:[230,60], 2:[230,200], 3:[310,130] }; // G2
const nodes1 = ['a','b','c'];
const nodes2 = ['1','2','3'];

// SVG offsets for left/right
const OFF2 = 0; // G2 already has x offset in pos2

// Current matching M (starts uniform)
let M = [[0.33,0.33,0.34],[0.33,0.34,0.33],[0.34,0.33,0.33]];

// ── STEPS CONFIG ────────────────────────────────────────────────────────────
const steps = [
  {
    title: 'Punto de partida',
    tag: { text: 'INICIALIZACIÓN', color: '#60a5fa' },
    text: `Tenemos dos grafos G1 (azul, nodos a,b,c) y G2 (lila, nodos 1,2,3). El matching M empieza siendo <b>uniforme</b>: cada nodo de G1 tiene la misma probabilidad (≈1/3) de emparejarse con cualquier nodo de G2. No sabemos nada todavía.`,
    formula: `M[a,i] ≈ <span class="hi">1/3</span>  <span>para todos a, i</span>\n\nObjetivo: encontrar M que <span class="hi">maximice rectángulos</span>.`,
    highlight_M: [],
    highlight_rect: false,
    show_Q: false,
    active_match: null,
  },
  {
    title: '¿Qué es un rectángulo?',
    tag: { text: 'CONCEPTO CLAVE', color: '#f0c040' },
    text: `Un <b>rectángulo</b> se cierra cuando:<br>
    1. Matcheamos <b>a → i</b> (M[a,i]=1)<br>
    2. Matcheamos su vecino <b>b → j</b> (M[b,j]=1)<br>
    3. Existe arista <b>a–b</b> en G1 (X[a,b]=1)<br>
    4. Existe arista <b>i–j</b> en G2 (Y[i,j]=1)<br><br>
    Los cuatro lados del rectángulo están presentes.`,
    formula: `Rectángulo válido si:\n  <span class="hi">X[a,b]</span> = 1  <span>(arista en G1)</span>\n  <span class="hi2">Y[i,j]</span> = 1  <span>(arista en G2)</span>\n  <span class="hi3">M[a,i]</span> = 1  <span>(a ↔ i)</span>\n  <span class="hi3">M[b,j]</span> = 1  <span>(b ↔ j)</span>`,
    highlight_M: [[0,0]],
    highlight_rect: false,
    show_Q: false,
    active_match: {a:0, i:0},
    draw_rect: {a:0, b:1, i:0, j:1},
  },
  {
    title: 'Calcular Q[a,i]',
    tag: { text: 'MATRIZ Q', color: '#4ade80' },
    text: `Para cada par (a, i), Q[a,i] cuenta <b>cuántos rectángulos</b> se formarían si matcheamos a con i, dado el matching actual M.<br><br>
    Miramos todos los vecinos b de a en G1 y todos los vecinos j de i en G2. Si M[b,j] es alto Y existen las aristas, Q[a,i] sube.`,
    formula: `Q[a,i] = Σ<sub>b</sub> Σ<sub>j</sub>  <span class="hi">X[a,b]</span> · <span class="hi3">M[b,j]</span> · <span class="hi2">Y[i,j]</span>\n\n<span>Forma matricial:</span>\n  Q = <span class="hi">X</span> @ <span class="hi3">M</span> @ <span class="hi2">Y</span>`,
    highlight_M: [[1,1]],
    highlight_rect: false,
    show_Q: true,
    active_match: {a:1, i:1},
    draw_rect: {a:1, b:0, i:1, j:0},
  },
  {
    title: 'Q matricialmente',
    tag: { text: 'CÓDIGO', color: '#c084fc' },
    text: `La suma doble <code>Σ_b Σ_j X[a,b]·M[b,j]·Y[i,j]</code> es exactamente un producto de tres matrices.<br><br>
    Primero X@M propaga la estructura de G1 a través del matching. Luego @Y verifica si esos vecinos también están conectados en G2. El resultado: ¿cuántos rectángulos cierra el par (a,i)?`,
    formula: `<span># Bucle equivalente (lento):</span>\nfor a in range(m):\n  for i in range(n):\n    for b in range(m):\n      for j in range(n):\n        Q[a,i] += <span class="hi">X[a,b]</span>*<span class="hi3">M[b,j]</span>*<span class="hi2">Y[i,j]</span>\n\n<span class="hi"># Versión vectorizada (rápida):</span>\nQ = X @ M @ Y`,
    highlight_M: [],
    highlight_rect: false,
    show_Q: true,
    active_match: null,
  },
  {
    title: 'SoftMax con beta',
    tag: { text: 'ENFOQUE', color: '#f0c040' },
    text: `Ahora usamos Q para actualizar M. Aplicamos exponencial con beta: pares con Q alto reciben probabilidad alta, pares con Q bajo la reciben baja.<br><br>
    Con beta pequeño → asignaciones suaves. Con beta grande → casi binario. Vamos subiendo beta poco a poco.`,
    formula: `M_new[a,i] = <span class="hi">exp(β · Q[a,i])</span>\n\n<span>Después Sinkhorn normaliza para que</span>\n<span>filas y columnas sumen 1.</span>\n\nβ: <span class="hi2">0.5</span> → <span class="hi">10.0</span>  (se va subiendo)`,
    highlight_M: [],
    highlight_rect: false,
    show_Q: true,
    active_match: null,
    converging: true,
  },
  {
    title: 'Matching final',
    tag: { text: 'RESULTADO', color: '#4ade80' },
    text: `Con beta alto, M se vuelve casi binaria. Cada nodo tiene un match claro. El algoritmo Cleanup elige el máximo de cada fila de forma voraz y nos da la asignación final.<br><br>
    El matching a→1, b→2, c→3 cierra <b>2 rectángulos</b>: el máximo posible para estos grafos.`,
    formula: `<span># Cleanup: voraz</span>\nfor _ in range(min(m,n)):\n  a, i = argmax(M_work)\n  M_binary[a, i] = 1\n  M_work[a,:] = -inf\n  M_work[:,i] = -inf\n\n<span class="hi">Rectángulos cerrados: 2 ✓</span>`,
    highlight_M: [[0,0],[1,1],[2,2]],
    highlight_rect: true,
    show_Q: true,
    active_match: null,
    M_final: [[0.95,0.03,0.02],[0.03,0.94,0.03],[0.02,0.03,0.95]],
  },
];

let currentStep = 0;

// ── COMPUTE Q ────────────────────────────────────────────────────────────────
function computeQ(M) {
  const m = 3, n = 3;
  const Q = Array.from({length:m}, () => Array(n).fill(0));
  for(let a=0;a<m;a++)
    for(let i=0;i<n;i++)
      for(let b=0;b<m;b++)
        for(let j=0;j<n;j++)
          Q[a][i] += X[a][b]*M[b][j]*Y[i][j];
  return Q;
}

// ── SVG HELPERS ──────────────────────────────────────────────────────────────
function svgLine(x1,y1,x2,y2,color,width,dash='',id='') {
  return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${color}" stroke-width="${width}" stroke-dasharray="${dash}" ${id?`id="${id}"`:''}/>`;
}
function svgCircle(cx,cy,r,fill,stroke,label,small=false) {
  return `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${fill}" stroke="${stroke}" stroke-width="2"/>
          <text x="${cx}" y="${cy+5}" text-anchor="middle" fill="#fff" font-size="${small?11:13}" font-family="JetBrains Mono" font-weight="700">${label}</text>`;
}

function renderSVG(step) {
  const s = steps[step];
  let svg = '';

  const useM = s.M_final || M;

  // Draw G1 edges
  const edges1 = [[0,1],[1,2]]; // a-b, b-c
  for(const [i,j] of edges1) {
    const [x1,y1] = pos1[nodes1[i]];
    const [x2,y2] = pos1[nodes1[j]];
    svg += svgLine(x1,y1,x2,y2,'#1e6bb8',2.5);
  }

  // Draw G2 edges
  const edges2 = [[0,1],[0,2],[1,2]]; // 1-2,1-3,2-3
  for(const [i,j] of edges2) {
    const [x1,y1] = pos2[nodes2[i]];
    const [x2,y2] = pos2[nodes2[j]];
    svg += svgLine(x1,y1,x2,y2,'#6d28a0',2.5);
  }

  // Draw rectangle highlight
  if(s.draw_rect && !s.highlight_rect) {
    const {a,b,i,j} = s.draw_rect;
    const [ax,ay] = pos1[nodes1[a]];
    const [bx,by] = pos1[nodes1[b]];
    const [ix,iy] = pos2[nodes2[i]];
    const [jx,jy] = pos2[nodes2[j]];
    // sides of rectangle: a-i, a-b, b-j, i-j
    svg += svgLine(ax,ay,ix,iy,'#ff8c42',2.5,'5,4');
    svg += svgLine(bx,by,jx,jy,'#ff8c42',2.5,'5,4');
  }

  // Draw final rectangles
  if(s.highlight_rect) {
    // rect 1: a-1, b-2 (a-b in G1, 1-2 in G2)
    const [ax,ay]=pos1['a'], [ix,iy]=pos2['1'];
    const [bx,by]=pos1['b'], [jx,jy]=pos2['2'];
    svg += svgLine(ax,ay,ix,iy,'#27ae60',2.5,'');
    svg += svgLine(bx,by,jx,jy,'#27ae60',2.5,'');
    // rect 2: b-2, c-3
    const [cx2,cy2]=pos1['c'], [jx2,jy2]=pos2['3'];
    svg += svgLine(bx,by,jx,jy,'#27ae60',2.5,'');
    svg += svgLine(cx2,cy2,jx2,jy2,'#27ae60',2.5,'');
  }

  // Draw matching lines (soft)
  for(let a=0;a<3;a++) {
    for(let i=0;i<3;i++) {
      const prob = useM[a][i];
      if(prob > 0.05) {
        const [x1,y1] = pos1[nodes1[a]];
        const [x2,y2] = pos2[nodes2[i]];
        const isHighlighted = s.highlight_M.some(([ra,ri])=>ra===a&&ri===i);
        const isRect = s.highlight_rect && ((a===0&&i===0)||(a===1&&i===1)||(a===2&&i===2));
        const color = isRect ? '#27ae60' : (isHighlighted ? '#ff8c42' : '#7f6b5d');
        const opacity = isRect ? 0.9 : (isHighlighted ? 0.85 : Math.min(prob * 2, 0.35));
        const width = isRect ? 3 : (isHighlighted ? 2.5 : 1);
        svg += svgLine(x1,y1,x2,y2,color,width,'',`match_${a}_${i}`);
        svg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${color}" stroke-width="${width}" opacity="${opacity}"/>`;
      }
    }
  }

  // Draw G1 nodes
  for(const [idx,name] of nodes1.entries()) {
    const [cx,cy] = pos1[name];
    svg += svgCircle(cx,cy,18,'#3498db','#1e6bb8',name);
  }

  // Draw G2 nodes
  for(const [idx,name] of nodes2.entries()) {
    const [cx,cy] = pos2[name];
    svg += svgCircle(cx,cy,18,'#8e44ad','#6d28a0',name);
  }

  document.getElementById('mainSvg').innerHTML = svg;
}

// ── MATRIX RENDER ────────────────────────────────────────────────────────────
function renderMatrix(containerId, data, rowLabels, colLabels, highlights, isProb=false) {
  const el = document.getElementById(containerId);
  let html = '<table class="mat"><tr><th></th>';
  for(const c of colLabels) html += `<th>${c}</th>`;
  html += '</tr>';
  for(let r=0;r<data.length;r++) {
    html += `<tr><th>${rowLabels[r]}</th>`;
    for(let c=0;c<data[r].length;c++) {
      const val = data[r][c];
      const isHi = highlights.some(([hr,hc])=>hr===r&&hc===c);
      const cls = isHi ? 'cell-hi' : (val===0 ? 'cell-dim' : '');
      const disp = isProb ? val.toFixed(2) : val;
      html += `<td class="${cls}">${disp}</td>`;
    }
    html += '</tr>';
  }
  html += '</table>';
  el.innerHTML = html;
}

// ── RENDER STEP ──────────────────────────────────────────────────────────────
function renderStep(idx) {
  const s = steps[idx];
  const useM = s.M_final || M;
  const Q = computeQ(useM);

  // progress
  document.getElementById('progressFill').style.width = `${((idx+1)/steps.length)*100}%`;
  document.getElementById('stepCounter').textContent = `Paso ${idx+1} / ${steps.length}`;
  document.getElementById('btnPrev').disabled = idx === 0;
  document.getElementById('btnNext').disabled = idx === steps.length - 1;

  // explanation
  const expEl = document.getElementById('expBox');
  expEl.innerHTML = `<div class="tag" style="background:${s.tag.color}22; color:${s.tag.color}">${s.tag.text}</div><br>${s.text}`;

  // formula
  const fEl = document.getElementById('formulaBox');
  fEl.innerHTML = s.formula.replace(/\n/g,'<br>');

  // SVG
  renderSVG(idx);

  // Matrices
  renderMatrix('matX', X, ['a','b','c'], ['a','b','c'], [], false);
  renderMatrix('matY', Y, ['1','2','3'], ['1','2','3'], [], false);
  renderMatrix('matM', useM, ['a','b','c'], ['1','2','3'], s.highlight_M, true);
  if(s.show_Q) {
    renderMatrix('matQ', Q.map(r=>r.map(v=>parseFloat(v.toFixed(2)))),
      ['a','b','c'], ['1','2','3'],
      s.highlight_rect ? [[0,0],[1,1],[2,2]] : (s.highlight_M||[]), true);
  } else {
    document.getElementById('matQ').innerHTML = '<span style="color:#64748b;font-size:0.75rem;font-family:JetBrains Mono">— se calcula en el paso 3 —</span>';
  }
}

function nextStep() { if(currentStep < steps.length-1) { currentStep++; renderStep(currentStep); } }
function prevStep() { if(currentStep > 0) { currentStep--; renderStep(currentStep); } }

// init
renderStep(0);
</script>
</body>
</html>
